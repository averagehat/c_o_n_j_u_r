* Schema
 - nodes get `rendered` each cycle  [or just commands? / bindings / extractions? ]
 - A bind of effect a to effect b is a combination of an extraction and a source
 - how do we avoid re-rendering the graph every tick?
 - put commands in a map by their offset so can do the following src block
 - look for the interpreter pattern in java/c++ b/c that's what we're doing. 
#+BEGIN_SRC cpp
unordered_map<int, Command> byTicks;
vector<Command> thisCycle; //  = byTicks [ getTime() 
int clock;  // `time` after transformations
for (auto& p : byTicks) {
 // filter by key
 // note that we have already sorted our commands and created a data structure
 // which propagates the ticks . . . the graph is small so space is cheap
 if ( time % p.first ) thisCycle.push_back(p.second);
}
#+END_SRC

Note that a clock-trigger is achieved by creating time as source :: IO Float and applying modulo after its extraction
Note that the type of NOT :: Int -> Int # and may be a special case of MUL
it may be better to define the whole thing as a pure function rather than store any state, with the state being modelled somehow by Source nodes
(i.e., last state). 
the default tick is constant
the other one is infinite: i.e. loading file happens only once
#+BEGIN_SRC cpp 
class Adder {
  int X;
  int Y;
  int visit() {
    return X + Y;
 }
}
#+END_SRC 

#+BEGIN_SRC cpp
#+END_SRC
#+BEGIN_SRC dot :file state.png
digraph StateExample {
 LastState -> Adder [bind=X]
 Rotation -> Adder [bind=Y]
 Adder -> 
#+END_SRC
 
#+BEGIN_SRC dot :file foo.png
digraph G  {
 // SourceTime -> Value -> Extract etc.
 SourceTime -> u_time
 u_tick [type=bool, default=false]
 SourceTime -> Modulo 4 ->  NOT -> u_tick 
 u_time -> Shader1
}
#+END_SRC

#+RESULTS:
[[file:foo.png]]
** e.g. Haskell
:PROPERTIES:
:header-args:haskell: :prologue ":{\n" :epilogue ":}\n"
:END:
#+begin_src haskell :results output
:set prompt-cont ""
#+end_src

#+RESULTS:

#+begin_src haskell :results raw
pyth5 n =
  [ (x, y, z)
  | x <- [1 .. n]
  , y <- [x .. n]
  , z <- [y .. n]
  , x ^ 2 + y ^ 2 == z ^ 2
  ]
#+end_src


#+begin_src haskell :results raw
pyth5 5  
#+end_src




#+BEGIN_SRC haskell 
data Foo = Bar | Baz | Bill deriving (Show,Eq)
:t Bar
:t Bill
print Bar
let f x = let y = 3 in
  y*x
f 2
#+END_SRC

#+RESULTS:
: <interactive>:146:1: error:
:     Variable not in scope: f :: Integer -> t

#+BEGIN_SRC haskell
data Label = Output | UF_f1 | UF_f2 | UF_f3  deriving (Show,Eq)
data Node = Node deriving Show
data Source = Adder Int Int | Extract Label Node | Mul Int Int deriving (Show)
print (Adder 3 3)
#+END_SRC 

Representing as subgrpahs because node attributes are actually 'Source Nodes' within a cluster
 Note: a const is different b/c it doesn't have to be recursively rendered
 'output' is just another thing to be extracted; it is the result of a side-effect of the container/subgraph (larger effects node)
 however, you might consider extracing output as monadic; it is different from a node passing on its values;
 though, consider this: any `Source` may have a monadic computation somewhere in its dependency trace. 
 Addition is an example of one such 'side-effect'


#+BEGIN_SRC dot :file subgraphs.png
digraph G {

    graph [fontsize=10 fontname="Verdana" compound=true];
    node [shape=record fontsize=10 fontname="Verdana"];

    subgraph cluster_0 {
        node [style=filled];
        "0_tex0" [label=texture] "0_out" [label=output];
        label = "Pika Model";
        color=blue;
    }

    subgraph cluster_1 {
        node [style=filled];
        "1_tex0" [label=texture] "1_out" [label=output];
        label = "1-input Shader";
        color=blue;
    }

    subgraph cluster_2 {
        node [style=filled];
        // "texture0" "Attr6";
        "2_tex0" [label=texture] "2_out" [label=output];
        label = "1-input Shader";
        color=blue;
    }

    // Edges between nodes render fine
    // "output" -> "Attr2";
    // "Attr2" -> "Attr3";
    "0_out" -> "1_tex0";
    "1_out" -> "2_tex0";

}
#+END_SRC

#+RESULTS:
[[file:subgraphs.png]]

    // Edges that directly connect one shader to another
//    "output" -> "texture0" [ltail=cluster_0 lhead=cluster_1];
//    "output" -> "texture0" [ltail=cluster_1 lhead=cluster_2];
#+BEGIN_SRC haskell
data Source = Adder Int Int 
 | Extract Label Node
 | Mul Int Int
 | Not Int
 | Const Int
 | Time Int
 | OSC Int
-- a Source is a node with a single value
type Tick = Int
data Edge = Edge Label Node Node
-- below describes expansions of the graph sort of 
data Command = Bind Tick Source Edge
  | Get Source
  | Put Int 
-- Const is the bottom; Time is secretly the other bottom
-- 
-- type Edge = Map (Label Source)
data Node = Node [(Label, Source)] -- i.e. edges. there are no attributes; attributes/defaults are edges with labels. 
-- defaults are Const-source edges.
type Default a = Bind (Const a) -- partial application?
-- or is it Adder -> Const
-- Const -> 
get :: (Monad m) => Source -> m Int
get (Adder x y)   = pure $ x + y 
get (Const x)     = pure x
get (Extract l (Node edges)   = get (find (== l))
visit (Adder x y) = Source (x + y)
#+END_SRC

#+RESULTS:
[[file:subgraphs.png]]





* Here
 - shaderActive needs to be changed. 
    - we don't need to check if it's active b/c it's either in the nodemap or it isn't
 - osc addresses need to be fixed (use an action map or a visitor, and generate addresses?
    or assume that the addresses are of the form
    /{command}/{arg1ID}/{arg2ID}  w/ optional float values
 - fix apply input chain (might require ofxAddons changes) [[file:~/of_v0.11.0_osx_release/apps/recur/c_o_n_j_u_r/src/ofApp.cpp::ofFbo%20ofApp::applyEffectShaderChain(vector<ofTexture>%20effectInput){][shaderChain]]
     ofFbo ofApp::applyEffectShaderChain(vector<ofTexture> effectInput){
 - then test with mac OSC :)
#+BEGIN_SRC cpp :result raw :includes "<stdio.h>"
int z = 0;
int i = 0;
switch (z) {
  case 4:
  i++;
  break;
  case 0:
  i += 99;
  break;
 }
printf("%d", i);
#+END_SRC

#+RESULTS:
: 99

#+BEGIN_SRC cpp
// you could generate OSC addresses but this is easier for now
string cmd = m.getArgAsString(0);
Id nodeId = m.getArgAsString(1);
ofxNode node = nodes[nodeId];
actionMap actions = { { { "LOAD_FILE", LOAD_FILE}, 
                         {"UPDATE_UNIFORM", UPATE_UNIFORM} } };
if (cmd == "LOAD_FILE") {
  dispatchUn(LOAD_FILE, node, m.getArgAsString(2));
}
else if (cmd == "UPDATE_UNIFORM") {
  dispatchUn(UPDATE_UNIFORM, node, m.getArgAsString(2), m.getArgAsFloat(3))
}

int dispatchUn(Action act, ofxNode node, string arg1, float arg2) {
int dispatchUn(Action act, ofxNode node, string arg1, string arg2) {
 
 switch act {
  case (LOAD_FILE):
    ofxNode.loadShaderFiles(arg1, arg2);
    return 0;
  default:
    return -1;
}

}
    
#+END_SRC

#+RESULTS:

* Problems
something is happening where texCoordVarying is always zero for simple.frag
* Tests

#+NAME: Setup!
#+BEGIN_SRC ein-python :session http://127.0.0.1:8888/notebooks/new.ipynb :results raw drawer
from pythonosc import udp_client
import time
localhost = "127.0.0.1"
port = 8000

client = udp_client.SimpleUDPClient(localhost, port)
# working
def msg(id, frag_name, U, on=True):
  vert_shader = 'shaders/shader.vert'
  msgs = [ ("LOAD_FILE", id, vert_shader, frag_name),
  ("TOGGLE_ACTIVE", id, on)] + \
    [("UPDATE_UNIFORM", id, i, U) for i in range(4)]

  for msg in msgs:
    time.sleep(.1)

    # print(msg)
    client.send_message("/graph", msg)
print('okay')
#+END_SRC

#+RESULTS: Setup!
:RESULTS:
[....]
:END:





#+NAME: Clear!
#+BEGIN_SRC ein-python :session http://127.0.0.1:8888/notebooks/new.ipynb :results silent drawer
msg("A1-0", gen_shader, .8, False)
msg("B2-0", invert, .1, False)
msg("C3-1", kscope, .1, False)
msg("D4-2", kscope, .1, False)
#+END_SRC

#+NAME: 9D698AC8-8621-47A6-8F3F-CE3C6CAA4A7B
#+BEGIN_SRC ein-python :session http://127.0.0.1:8888/notebooks/new.ipynb :results raw drawer
for x in range(1):
  gen_shader = 'shaders/hypnotic_rings.frag'
  simple_gen = 'shaders/simple.frag'
  kscope = 'shaders/kaleidoscope-failing.frag'
  invert = 'shaders/invert.frag'
  mirrorX = 'shaders/mirrorX.frag'
  mirrorY = 'shaders/mirrorY.frag'
  client.send_message("/shader/start", True)
  msg("A1-0", simple_gen, .8)
#  msg("B2-0", mirrorY, .5)
#  msg("C3-1", mirrorX, .1)
  # msg("D4-2", mirror, .1)
## msg("C3-1", 'shadres/invert.frag' .5)
  print('sent')
  # time.sleep(6)
print('done.')
#+END_SRC

#+RESULTS: 9D698AC8-8621-47A6-8F3F-CE3C6CAA4A7B
:RESULTS:
[....]
:END:











