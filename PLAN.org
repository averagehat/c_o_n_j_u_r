By Mike Panciera

* 3D scenes

3D is in this conjur fork; it is working but I get weird feedback, I suspect it is from something with the fbo. I think if you resolve that 
you're left with just some fixes to get it working on the Pi. Users can set up their scene in scene.config and toggle it on/off there.
Probably there should be an OSC switch to turn 3d mode off, like detour. Getting a user interface for 3D is not something I've thoguht about;
the idea of using a graph, whether json or graphviz, comes from errogenous tones STRUCUTRE product; once the structure of the graph is determined 
user interaction is greatly simplified, and you could even render the object and some shaders without ever touching the 3d side; maybe hotkey some other models;
then you use vertex uniforms as much as you can to effect 3D space, which recur already supports. 
base.frag and base.vert work well with pikachu, who I got from https://github.com/Eoey1/OF-Shader-Exam
This guy has very good practices and examples https://github.com/73-ch/vjSystem

* Shader Extension Notes
 - shaderActive needs to be changed. 
    - we don't need to check if it's active b/c it's either in the nodemap or it isn't
 - osc addresses need to be fixed (use an action map or a visitor, and generate addresses?
    or assume that the addresses are of the form
    /{command}/{arg1ID}/{arg2ID}  w/ optional float values
 - fix apply input chain (might require ofxAddons changes) [[file:~/of_v0.11.0_osx_release/apps/recur/c_o_n_j_u_r/src/ofApp.cpp::ofFbo%20ofApp::applyEffectShaderChain(vector<ofTexture>%20effectInput){][shaderChain]]
     ofFbo ofApp::applyEffectShaderChain(vector<ofTexture> effectInput){
 - then test with mac OSC :)

You could use the following addon, if it compiles, to abstract out shader composition:
https://github.com/patriciogonzalezvivo/ofxFX

I got 1-input shader chaining to work in my fork ( got 4 in a row to work at least). I just did this by putting them in a vector, mainly. That might be in an old commit or commented out.
2-input shaders need to be told how to behave with some tree/graph representaiton, see [[Schema]]

Oh there is also stuff for cross-platform shaders in this repo using glsl headers works

* Schema
** Graphviz
Use graphviz dot files to specify complex modulation setups. 
If you don't want to work with dot files directly, you can convert them to json easily. 
But Graphviz is very well suited  for 'live coding' applications in this space; it's a functional language supported by text editors, syntax highlighting, many libraries.
It is very concise, and it can express data flow and operations very well. It's also easy to work with, because the nodes and edges are just dictionaries (hashmaps) after 
you parse them. 
you could use labels for the file names or layer numbers or just use the IDs (which is what is actually written down)
the named shaders would match up with those layers/slots and/or file names
you can also specify stuff in the edges between nodes
if you use the write editor the actual graph will render as a PNG in the same window (as with emacs org-babel) 
in the following example, we use audio input attenuated by an OSC parameter, send it multiple places, every six seconds take a screenshot with detour
we also take a snapshop with detour every six seconds and then pipe that back into our pipeline

#+BEGIN_SRC dot :file with3D.png
digraph LittleExample {
 OSC -> u_x1 -> Mul2;
 Audio -> LowPassFilter -> Mul2 -> u_x0;
 u_x0 -> { GenShader, RotationX, ModelVertShader};
 Model3D -> VertShader -> ModelFrag -> blur;
 {blur, playerA} -> chromaKey;
 LowPassfilter -> u_x9 -> chromaKey;
 OSC[label="/shaders/param/1"];
 PNG [filename="foobar.png"];
 time -> Modulo6 -> detourTrigger -> PNG;  //
 PNG -> Model3D [label="e.g. as texture"]; // or could go in a s
 LowPassFilter -> BackgroundHue;
 RotationX -> Camera;
 {Camera, Model3D, BackgroundHue} -> Scene3D;
}
#+END_SRC

#+RESULTS:
[[file:state.png]]

You can use the interpreter pattern or the visitor pattern, and have python send out the computed state (i.e., the new uniform, rotation values, and file names, etc.)
to c_o_n_j_u_r; conjur already has a lot of hooks, and you can add more easily if you use the ofxOSCPubSub addon, code for that below
You can do the mathematical computations, parse audio data, etc. on the python side, and have the side-effects rendedered on the conjur side.

It breaks down very simply as function composition/data flow, and can be modelled simply; if you consider that data is constantly flowing, the graph just represents a call stack.
so you visit each node (order doesn't actually matter; you just need to start at the 'display' node (the terminal node might be missed otherwise)

the following code assumes that you've gone through and given the edges meaningful names, matched up input/types so that you can guess what the user intended, and so on.
the incoming edges are the 'dependencies' that need to be resolved in order for the current node ot resolve itself and produces its own output (and render). 
So you resolve dependencies recursively, storing the result in a dictionary. (for example, you've resolved the uniform, storing it in 'u_x0')
#+BEGIN_SRC python
def recursiveVisist(node: Node) -> dict:
   attributes = {}
   for edgeName, dependency in node.incomingEdges.items():
      # if an attribute hasn't changed, don't update it so you don't send the osc
      if self.attributes
      newAttributes[edgeName = recursiveVisit(dependency)
   #newAttributes.update(self.attributes)
   result = self.compute(**newAttributes)
   self.attributes = newAttributes
   return result

recursiveVisist( terminalDisplayNode )

# i.e.
class Node(NamedTuple):
  func: Callable
  id: str
  def compute(self, **kwargs):
    func(**kwargs)

  def recursiveVisist().... # etc.


class Shader(Node):
   # earlier:
    edges = {'uniforms' :  [0,  0.0] } # etc. u_x1, u_x2, u_x3,
  # def compute(self, u_x0, u_x1, u_x2, u_x3, tex0=None, tex1=None):
  def compute(self, uniforms, tex0=None, tex1=None):
    for i, value in enumerate(uniforms):
      sendosc( f"/shader/{self.id}/{i}", value)
    # a shader doesn't actually have a result, so just indicate that it can be used  as input texture
    return Texture(self.id)

class Add(Node):
  def compute(self, a, b):
    return a + b    
# OR
from functools import partial
import operator

Add = partial(Node, operator.add)

# below are root nodes, they have no incoming attributes
class Data(Node):
  def __init__(self, data):
    self.data = data
  def compute(self):
    return data

class OSCListener(Node):
  address: str  # with NamedTuple/dataclass, don't need an explicit __init__
  inputype: int
  def compute():
    # listen for osc...
 
#+END_SRC
** More Notes
 - nodes get `rendered` each cycle  [or just commands? / bindings / extractions? ]
 - A bind of effect a to effect b is a combination of an extraction and a source
 - how do we avoid re-rendering the graph every tick?
 - put commands in a map by their offset so can do the following src block
 - look for the interpreter pattern in java/c++ b/c that's what we're doing. 

Note that a clock-trigger is achieved by creating time as source :: IO Float and applying modulo after its extraction
Note that the type of NOT :: Int -> Int # and may be a special case of MUL
it may be better to define the whole thing as a pure function rather than store any state, with the state being modelled somehow by Source nodes
(i.e., last state). 
the default tick is constant
the other one is infinite: i.e. loading file happens only once
#+BEGIN_SRC cpp 
class Adder {
  int X;
  int Y;
  int visit() {
    return X + Y;
 }
}
#+END_SRC 

#+BEGIN_SRC dot :file state.png
digraph StateExample {
 LastState -> Adder [bind=X]
 OSC -> Adder [bind=Y]
 Adder -> NewRotation
 Adder -> LastState [label="IO"]
}
#+END_SRC

#+BEGIN_SRC dot :file modularComplex.png
digraph G  {
//    graph [fontsize=10 fontname="Verdana" compound=true];
//    node [shape=record fontsize=10 fontname="Verdana"];
    shape=record;
    compound=true;
    subgraph cluster_0 {
        node [style=filled];
      u_0 [label="/shader/params/u0"] 
      u_1 [label="/shader/params/u1"] 
      u_3 [label="/shader/params/u3"]   
      u_2 [label="/shader/params/u2"];
      u_swap [label="/shader/swapFile"];
        label="OSC Stuff (implied elsewhere)"
        style=dotted;
    }
   subgraph cluster_1 {
       label="3D Scene";
        node [style=filled];
      bg [label="background"];
      camera [label="camera"];
      light  [label="light",type="unknown"];
      shape [label="3D Model",shape=cylinder]
      modelTex [label="etc."]
        color=blue;
} 
 Model3D [label="Something.stl",shape=cylinder];
 image [label="background.png"];
 Grayscale [label="grayscale.frag",shape=octagon,style=bold];
 Blur [label="blur.frag",shape=octagon,style=bold];
 {light, camera} -> shape [label="target",style=dashed];
 image [shape=rectangle]
 image -> bg;     
 u_3 -> Grayscale [label="more edges=re-use"];
 u_swap -> Blur [style=dashed,label="otherFile.frag"];
 u_3 -> Multiply2;
 u_time [style=filled];
 u_time -> Multiply2;
 Modulo4 [label="Modulo4 (x % 4)"];
 IF [label="IF (A && B): B" ];
 Multiply [label="Multiply (scale)"];
 u_time -> Modulo4 -> ToBoolean;
 {ToBoolean, lightOn} -> IF;
 IF -> light  [label="toggle on/off"];
 HypRings -> Grayscale -> LumaKey;
 u_time -> Sin -> Multiply;
 ten [label="100.0",color=yellow];
 ten -> Multiply [style=dashed];
 Multiply -> RotateX [label="for scaling"];
 Mirror [label="mirror.frag",shape=octagon,style=bold];
 HypRings [label="hypnotic_rings.frag",shape=octagon];
 AudioSource [style="filled"];
 AudioSource -> BandPassFilter -> { BandLow };
 AudioSource -> { BandHi, BandMid } [style=dashed];
 BandLow -> Scale -> Invert -> RotateY;
 {RotateY, RotateX}  -> camera;
 Multiply2 -> speed_uniform -> HypRings;
 { u_0, u_1, u_2 } -> HypRings [label="u_x*"];
 moreosc [label="OSC (implied elsewhere)",style=filled];
 unis [label="u_x4,u_x5...(implied elsewhere)"];
 HypRings -> Blur;
 moreosc -> unis  -> ModelVert;
 // ChromaKey -> LumaKey -> DISPLAY;
 { RotateY, RotateX } -> shape;
 ChromaKey [label="chromaKey.frag",shape=doubleoctagon];
 LumaKey [label="lumakey.frag",shape=doubleoctagon];
 ModelVert [label="example.vert",shape=diamond];
 ModelFrag [label="example.frag",shape=octagon,style=bold];
 Model3D -> ModelVert -> ModelFrag -> shape;
 modelTex -> Mirror [ltail=cluster_1,style=bold,color=blue];
 DISPLAY [color=red,style="filled,bold",shape=square];
 {Mirror, Blur} -> ChromaKey -> LumaKey -> DISPLAY;
}
#+END_SRC
#+RESULTS:
[[file:modularComplex.png]]
 

** Day2
#+BEGIN_SRC ein-python 
if False:
# def resolve_edges(edges: Edges[T]) -> Tuple[T, History]

# In[133]:


from dataclasses import dataclass
from typing import Callable, Any, T, Sequence, Tuple, Dict, Union
from typing_extensions import  Literal
from pydantic import BaseModel # for json schemaing etc
from toolz import dicttoolz as dtz
from functools import partial 
NType = Literal[ 'ADD', 'MUL', 'SHADER', 'SCENE', 'MODEL']
History = Sequence[Tuple[type, Dict[str, str]]]
@dataclass
class Node:
  _func: Callable
  edges: Dict[ str, 'Node' ] # could store edge types here
  id: str
  def edgeTypes(self) -> Dict[ str, NType ]:
    '''  useful for dot compilation'''
  # TODO: this is a class method;
  # TODO: please don't use 'return' as an attr lol 
    return tlz.dissoc( self._func.__annotations__, 'return' )

  def apply(self) -> Tuple[Any, History]:
    args, history = {}, []
    for e, src in edges.items(): # the edge is the label basically
      t, hist = src.apply()
      history.append(hist)
      args[e] = t
    log = self.__class__, dtz.valmap(args, lambda x: x.id) # args.keys(), ags.values() 
    history.append( log )
    return _func(**args), history

def _add(x: int, y: int) -> int: 
  return x + y

def _mul(x: int, y: int) -> int:
    return x * y

def _id(x: UType) -> UType:
 return x

Add = partial(Node, _add)
Mul = partial(Node, _mul)
# just treat a uniforms like any other edge I guess
                   
class Texture: ...
UType = Union[str, int, float, Texture]
Uniform = partial(Node, _id)
Const = Uniform
#+END_SRC


you could use json schema for the OSC, generating it from pydantic automatically
pydantic fields let you specify min & max, regular expressions, etc if you want

#+BEGIN_SRC python
import pydantic

class OSCSchema(pydantic.BaseModel):
  shader0file: str
  shader: Shader
#+END_SRC

 use ofxOSCPubSub to make OSC easy to watch
#+BEGIN_SRC cpp
ofxSubscribeOsc(ADDR, SUBPORT, "/3D/lightOn", lightOn);
ofxSubscribeOsc(ADDR, SUBPORT, "/3D/camera/distance", &camera.getPosition());
ofxSubscribeOsc(ADDR, SUBPORT, "/3D/scene/translation", sceneTranslation);
 
 for (int i = 0; i < 6; i++) {
   shaderUniformsF[ UNIFORM_PREFIX_FLOAT + ofToString(i) ] = 0;
     }
 for (int i = 0; i < 2; i++) {
   shaderUniformsB[ UNIFORM_PREFIX_BOOL + ofToString(i) ] = false;
     }
 string EMPTY = "UNINITIALIZED";
 string uname;
 for (int i = 0; i < 2; i++) {
   uname = UNIFORM_PREFIX_TEXTURE + ofToString(i);
   shaderUniformsTexIds[ uname ] = EMPTY;
   ofxSubscribeOsc(HOST, "/3D/shaderGraphExample/onlyOneShader/" + uname, [=](const string srcID)) {
        shaderUniformsTexIds[ uname ] = srcID;
     }
  }
 for (auto& p : shaderUniformsF ) {
   addr = "/3D/model/" + "frag" + "/" + p.first;
   // if we use the key, the types will still work out in the end
   ofxSubscribeOsc(HOST, addr, [=](const float x) {
         shaderUniformsF[p.first] = x;
         }
fxSubscribeOsc(HOST, "/3D/cam/position", [=](const glm::vec3 pos) {
   camera.setPosition(pos); // camera.lookAt(lookat);

#+END_SRC

Node attributes are actually 'Source Nodes' within their larger node (subgraph)
 Note: a const is different b/c it doesn't have to be recursively rendered
 'output' is just another thing to be extracted; it is the result of a side-effect of the container/subgraph (larger effects node)
 however, you might consider extracing output as monadic; it is different from a node passing on its values;
 though, consider this: any `Source` may have a monadic computation somewhere in its dependency trace. 
 Addition is an example of one such 'side-effect'

* More Python Implementation Stuff
** Compute Nodes
 etc. see `dir(operator)`
#+BEGIN_SRC python
import math
import operator

EMPTY = None    
Add = partial(Node, _add)
Mul = partial(Node, _mul)
Abs = partial(Node, abs)
Const = partial(Conster, None) # just store a value
Negate = partial(muler, a=const(_c=-1))
Mod = partial(Node, operator.mod)
Sin = partial(Node, math.sin)
Pair = partial(Node, lambda a,b: (a,b))
And = parital(Node, operator.and_)
Or = parital(Node, operator.or_)
IfA = partial(Node, lambda a, b: a if (a and b) else EMPTY
IfB = partial(Node, lambda a, b: b if (a and b) else EMPTY
Sub = partial(Node, operator.sub)
Random = partial(Node, random.random) # random float between 0 and 1
#
# OPERATORNODES = Add, Mul, Abs, Const, Negate, Mod, Sin, Pair, First, Or

def _clamp(start, end, a):
    return min(max(start, a), end)
    
def _smoothstep(start, end, a):
    t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
def _mix(start, end, a):
    start*(1.0 - a) + (end * a)
Calmp  = partial(Node, _clamp) # etc.

#Scale100 = partial(muler, _id='scale100', a=const(_c=100))
First = partial(Node, lambda a: a[0])
Second = partial(Node, lambda a: a[1])

#+END_SRC

Here is another version of the node implementation
You can ignore or get rid of all the type annotations

#+BEGIN_SRC python
from dataclasses import dataclass
from typing import Callable, Any, T, Sequence, Tuple, Dict, Union
from typing_extensions import  Literal
from pydantic import BaseModel # for json schemaing etc
from toolz import dicttoolz as dtz
from functools import partial 
NType = Literal[ 'ADD', 'MUL', 'SHADER', 'SCENE', 'MODEL']
History = Sequence[Tuple[type, Dict[str, str]]]
@dataclass
class Node:
  _func: Callable
  id: str
  edges: Dict[ str, 'Node' ] # could store edge types here
  def edgeTypes(self) -> Dict[ str, NType ]:
    '''  useful for dot compilation'''
  # TODO: this is a class method;
  # TODO: please don't use 'return' as an attr lol 
    return tlz.dissoc( self._func.__annotations__, 'return' )

  def apply(self) -> Tuple[Any, History]:
    args, history = {}, []
    for e, src in self.edges.items(): # the edge is the label basically
      t, hist = src.apply()
      history.append(hist)
      args[e] = t
    log = self.__class__, dtz.valmap( lambda x: x.id, self.edges) # args.keys(), ags.values() 
    history.append( log )
    return self._func(**args), history

def _add(x: int, y: int) -> int: 
  return x + y

def _mul(x: int, y: int) -> int:
    return x * y

class Texture: ...
UType = Union[str, int, float, Texture]
def _id(x: UType) -> UType:
 return x, []

Add = partial(Node, _add)
Mul = partial(Node, _mul)
# just treat a uniforms like any other edge I guess
                   
Uniform = partial(Node, _id)
class Const(Node):
    def __init__(self, id, v):
        self.id = id
        self._func = lambda: (v, [])
        self.edges = {}
    def apply(self): return self._func()
    

#+END_SRC

Here is a little 'algebra' of commands to be sent over OSC
https://github.com/2bbb/ofxPubSubOsc
not to difficult for the OF side to handle this by storing it in state via hooks when commands come in and then rendering
as usual on the update() and draw() methods
#+BEGIN_SRC python


class Command:
 requireChange: bool

class ChangeCommand(Command):
  '''only run this command if inputs have changed.
  The python side of things should have been able to figure that out, though, probably....'''
  requireChange = True 

class AlwaysCommand(Command):
 requireChange = False

class ShaderBegin(AlwaysCommand): ...

class LoadFile(ChangeCommand):
 node: Node # /  ID
 fileName: str

class SetUniform(ChangeCommand):
 uniform: Node

def shader_0_input(fileName: str, *uniforms) -> Texture: # u_x0: float, u_x1: float, u_x2: float, u_x3: float) -> Texture:
   # need an id for these commands.
  cmds = [ SetUniform( u.utype, u.label, u.value, u.id ) for u in uniforms ] # requires access to the node ids
  cmds += [ LoadFile(fileName) ] 
  cmds += [ ShaderBegin() ]
  return cmds


class Command:
 requireChange: bool

class ChangeCommand(Command):
  '''only run this command if inputs have changed.
  The python side of things should have been able to figure that out, though, probably....'''
  requireChange = True 

class AlwaysCommand(Command):
 requireChange = False

class ShaderBegin(AlwaysCommand): ...

class LoadFile(ChangeCommand):
 node: Node # /  ID
 fileName: str

class SetUniform(ChangeCommand):
 uniform: Node

def shader_0_input(fileName: str, *uniforms) -> Texture: # u_x0: float, u_x1: float, u_x2: float, u_x3: float) -> Texture:
   # need an id for these commands.
  cmds = [ SetUniform( u.utype, u.label, u.value, u.id ) for u in uniforms ] # requires access to the node ids
  cmds += [ LoadFile(fileName) ] 
  cmds += [ ShaderBegin() ]
  return cmds


#+END_SRC

Here is an example of loading the above graphviz code into python; no output but it worked fine.
In my mind you 
#+BEGIN_SRC python
from typing import NamedTuple
import networkx as nx
# you also need to install pygraphviz for this to work
dotFile = open('modularComp.dot')
g = nx.drawing.nx_agraph.read_dot(dotFile)
dag = g.to_directed()
sort_iterator = nx.algorithms.dag.topological_sort(g)
# the below gives a tuple of the nodes's ID (as written in the file) and all of the metadata of the node
# i.e. label, type, filename, whatever.
dependency_sorted = [NodeInfo(k, dag.nodes[k]) for k in sort_iterator]
#+END_SRC

You would want to normalize the node representation; you fill in defaults, match special ids/labels, read in special attributes; you can also check
the integrity of the graph if you want. You may even want to break nodes into smaller nodes, so that the user can specify a lot implicitly in a single node;
then on the implementation side you break things down into simplest pieces. Not really needed, but it's interesting that the whole problem space can be represented, more or less,
with individual nodes with single attributes, which can PUT or GET or perform binary or unary operations.


#+BEGIN_SRC python


to_visit[0]
Primitives = (bool, str, float)
MODELEXTS = ('.stl', '.obj') # etc.
def fix_node(id: str, dotData: dict):
    label = node['label'].strip()
    if label.endswith('.vert'):
        node = VertNodeInfo(filename=label)
    elif label.endswith('.frag'):
        node = FragNodeInfo(filename=label)
    elif any( (label.endswith(ext) for ext in MODELEXTS) ):
        node = ModelNodeInfo(filename=label)
    elif label.startswith('u_'):
        u_type = dotData.get('type')
        if not u_type:
            warning_log(f"suspicious u_ prefix in {id} metadata {dotData}")
            continue
        node = UniformNodeInfo(name=label, type=u_type)
    elif label.endswith('.png'):
        node = TextureNodeInfo(filename=label)
    else:
        any ( label.startswith(t) for t in 
    
        
def visit_node(id: str, dotData: dict):
class RecurNode(NodeInfo):
    id: str
    metadata: dict
    edges: dict
    def visit()

#+END_SRC


* N-shader Implementation
 - [X] restore working non-3D
 - [X] move shaders into a vector/stack: sort of
 - [X] read the order from scene.json as filenames and push those on stack etc.
 - [ ] see if top order will work with the stack -- seems to?
 - current osc for params and setting files won't work on pi b/c it demands two arguments in osc 
 - [X] implement static images (from [[file:~/of_v0.11.0_osx_release/addons/ofxVideoArtTools/src/detour.cpp::img.allocate(ofGetWidth(),%20ofGetHeight(),%20OF_IMAGE_COLOR);][detour.cpp code]] )
   #+BEGIN_SRC cpp 
    ofImage img;
    img.allocate(ofGetWidth(), ofGetHeight(), OF_IMAGE_COLOR);
    img.setColor(ofColor::blue);
    img.update();
    default_frame = img.getPixels();
    #+END_SRC
 - [X] implement players  [[file:src/ofApp.cpp::drawPlayerIfPlayingOrPaused(cPlayer);][ofApp.cpp]]  by calling drawPlayerIfPlayingOrPaused when we hit it in the stack
      and not calling drawCaptureAndPlayers; 
 - [X] implement 'capture' in the same way as players
 - [ ] actually test/use above implementations

** Figure out 3D video feedback problem
 - using my understanding of fbo now
** Fix ordering
 - will it work if I pop the stack as we go? Isn't that the natural thing?:
  but for this to work we have to know how many we've used; only shaders can pop the stack
  and only 1-input and 2-input shaders can
  conjur doesn't seem to know if a shader is two-input or not
#+BEGIN_SRC dot :file recur.png
digraph G {
       {0, 1} -> 2 -> 3;
}
#+END_SRC

#+BEGIN_SRC dot :file out.dot
digraph G {
       4 -> 1;
       0 -> 3;
       {1, 3} -> 2;
}
#+END_SRC
#+RESULTS:
[[file:out.dot]]

#+BEGIN_SRC cpp :result raw :flags -std=c++11
#include "stdio.h"
#include <vector>
#include <string>
#include <iostream>

typedef std::string conjur;
typedef std::string ofTexture; typedef std::string ofImage; typedef std::string ofPixels;

class recurNode {
public:
  virtual ofTexture render(int width, int height, std::vector<ofTexture> textures) = 0;
  //void setup(string file) = 0;
};

class shaderNode : public recurNode {
public:
  ofTexture render(int width, int height, std::vector<ofTexture> textures) {
     fbo = shader.apply(textures);
     return fbo.getTexture();
 }
  //void setup() {std::cout << "setting up";};
  shaderNode(conjur sh) { shader = sh; };
private: conjur shader;
};

class videoNode : public recurNode {
  ofTexture render(int width, int height, std::vector<ofTexture> textures) {
    if (player.alpha > 0 && ( player.status == "PLAYING" || player.status == "PAUSED" ) ){
        player.draw(0, 0, width, height);
        return player.getTexture();
  }
}
  //void setup() {std::cout << "setting up";};
  videoNode(recurVideoPlayer pl) { player = pl; };
  private: recurVideoPlayer player;
}

class videoNode : public recurNode {
  ofTexture render(int width, int height, std::vector<ofTexture> textures) {
        videoGrabber.draw(0,0, width, height);
        return videoGrabber.getTexture();
}
  //void setup() {std::cout << "setting up";};
  videoNode(captur gr) { videoGrabber = gr; };
  private: captur videoGrabber;
}

class imageNode : public recurNode {
public:
  ofTexture render(int width, int height, std::vector<ofTexture> textures) {
     ofPixels pixels = img.getPixels();
     ofTexture outTexture;
     outTexture.loadData(pixels.getData(), pixels.getWidth(), pixels.getHeight(), GL_RGB);
     img.draw(0, 0, width, height);
     return outTexture;
 }
  //void setup() {std::cout << "setting up";};
  imageNode(ofImage im) { img = im; };

private: ofImage img;
  };
int main () {
 printf("HIL");
 shaderNode n { "foo" };
 n.setup();
 n.render({});
}
#+END_SRC

#+RESULTS:


#+BEGIN_SRC cpp :result raw :flags -std=c++11
#include "stdio.h"
#include <vector>
#include <string>
#include <unordered_map>
#include <iostream>


enum AttrType {INT,FLOAT,STRING,EMPTY};  
enum NodeType {SHADER,MODEL,UNIFORM};

class Value { 
public:
  std::string value;
  AttrType type;
  Value(std::string v, AttrType t) {
      value = v; type = t; 
  }
    Value() {value = ""; type = EMPTY;}
  };
class OFNode {
public:
  bool operator == (const OFNode& n) const {
      return name == n.name;
  }

 // vector<attribute> attributes; 
  // ofNode(vector<attribute> att) { attributes = att; }
  OFNode(std::string na, int att, int e) 
  { name = na; attributes = att; edges = e; } // ributes; // Map from string to int
  OFNode() {attributes = 0; edges = 0;}
private: std::string name; int edges, attributes;
};



int main () {
 OFNode n {"foo", 2, 3};
std::cout << "hi";

}
#+END_SRC

#+RESULTS:
: hi


* Feb 6

*** Simple Recur Graph
#+BEGIN_SRC dot :file simple.dot
digraph G {
hypnotic_rings [slot=0];
mirror [slot=1];
luma [slot=2];
hypnotic_rings -> mirror -> wipe;
line -> wipe -> invert;  
{hypnotic_rings, invert} -> luma;
}
#+END_SRC

*** Dot To JSON
Dot to json which goes into scene.json

#+BEGIN_SRC python :session :results output
import networkx as nx
import json

g = nx.drawing.nx_agraph.read_dot('simple.dot')
gm = nx.DiGraph(g)
lexi = list(nx.topological_sort(nx.line_graph(gm)))
ns = []

for x in lexi:
    if not (x[0] in ns):
        ns.append(x[0])

ds = [ {"file" : f"shaders/{k}.frag",
         # "arity" : get_arity(k), # unused
         "id" : k,
         "outEdges" : len(gm[k]), # unused
         "inTextures" :  list(gm.predecessors(k)),
         "addresses" : [ f"{shader/{k}" ] # slot addresses are hidden
        }
 for k in ns]

MEANINGFUL_ATTRIBUTES = { 'slot' }
for d in ds:
  meta = gm.nodes[d[id]]
  for attr in ( MEANINGFUL_ATTRIBUTES & meta.keys() ):
    if not (attr in meta):
       d[attr] = meta[attr]

print(json.dumps(ds, indent=4))

#+END_SRC

#+RESULTS:
#+begin_example
[
    {
        "file": "shaders/line.frag",
        "id": "line",
        "outEdges": 1,
        "inTextures": []
    },
    {
        "file": "shaders/hypnotic_rings.frag",
        "id": "hypnotic_rings",
        "outEdges": 2,
        "inTextures": []
    },
    {
        "file": "shaders/mirror.frag",
        "id": "mirror",
        "outEdges": 1,
        "inTextures": [
            "hypnotic_rings"
        ]
    },
    {
        "file": "shaders/wipe.frag",
        "id": "wipe",
        "outEdges": 1,
        "inTextures": [
            "mirror",
            "line"
        ]
    },
    {
        "file": "shaders/invert.frag",
        "id": "invert",
        "outEdges": 1,
        "inTextures": [
            "wipe"
        ]
    }
]
#+end_example

Other Node operations
Use with e.g. pysound to create audioreactivity etc.
#+BEGIN_SRC python :results raw :session
import random, math, operator
from functools import partial

def get_func(id, G):
    d = G.nodes[id]
    s = id.lower()
    if d:
        if 'value' in d: # const node
            func = lambda: d['value']
        if d.get('finish'): # terminal node
            func = lambda *x: x
    elif hasattr(operator, s):
        func = getattr(operator, s)
    elif hasattr(math, s):
        func = getattr(math, s)
    elif hasattr(random, s):
        func = getattr(random, s)
    else:
        print(f"{id} complains. {d}")
    return func

def handle(G, RG, n):
    func = get_func(n, G)
    incoming = RG[n]
    results = list(map(partial(handle, G, RG), incoming))
    print(f"attmpting: {func} on {results} of {type({} if not results else results[0])}")
    return func(*results)

G = nx.DiGraph()
G.add_nodes_from([('Add', {}), ('Mul', {}), ('Abs', {}), ('Sin', {}), 
                  ('Const1', dict(value=2)), ('Const2', dict(value=3)), ('Random', {}),
                  ("u_x0", dict(finish=True))])
G.add_edges_from([('Const1', 'Sin'), ('Mul', 'Abs'), ('Const2', 'Add'), ('Random', 'Mul'),
    ('Sin', 'Mul'), ('Abs', 'Add'), ('Add', 'u_x0')])
RG = G.reverse()

print( handle(G, RG, 'u_x0') )

#+END_SRC

#+RESULTS:


one could swap out `get_func` above with whatever, and have it generate /commands/ rather than perform them


Other things

#+BEGIN_SRC python :results raw :session

def get_arity(s): 
    if s.lower().startswith( ('chroma', 'luma', 'othermix') ) :
        return 2
    elif s in {'hypnotic_rings.frag', 'Preacher', 'Ribald', 'Gopher', 'Salesman'}:
        return 0
    else: return 1

ds = [ {"file" : f"shaders/{k}.frag",
         "arity" : get_arity(k), # unused
         "id" : k,
         "outEdges" : len(gm[k]), # unused
         "inTextures" :  list(gm.predecessors(k))
        }
 for k in ns]
#+END_SRC


* Feb 7
** Polymorphism
i.e. 
#+BEGIN_SRC cpp
typedef mpark::variant<ofImage,ofShader,recurVideoPlayer,captur,ofLight> recurValue;
struct renderVisitor {
    ofTexture operator()(ofImg img) 
}
int result = mpark::visit( simpleVisitor{}, u );
#+END_SRC

shader nodes which are in the slots (shader layers) need a special label so that they can be updated when the existing OSC hooks are called
the JSON generaed from the graph parse includes the OSC addresses (guaranteeing consistency) so the OF side just has to add the hook
alternatively something like below, which is useful for validating the graph
you could make secret OSC addresses for more or less /all/ nodes, allowing their output value to be over-written by the user
but here we just generate from default/const nodes

There is a metadata representation of shaders, image textures, etc. that is worth considering seperately from
the graph representation. 
That metadata is easily represented in struct/namedtuples/dataclasses
You can use this metadata to check the integrity of the graph (for example: a shader (or other node) should always have exactly as many incoming edges as it can [considering default values as incoming edges of `Const` nodes. You can also check the types and match them up, etc.



** Continuing Work
This branch has a little proof of concept using only textures. OSC needs to be plumbed.
*** Nodes
    The following nodes need to be handled to catch up with recur:
 - video player nodes
 - uniform 'nodes' (via OSC plumbing)
Other nodes:
 - static image nodes (this requires no effort really)
 - compute nodes (e.g., using time) -- works once we have python osc dispatching [[Modular-style stuff]]
 - 3D rendering nodes
   
Currently conjur loads a json file (`scene.json`) at setup which determines the shader order and will determine parameter setup. 

*** Modular-style stuff
 - it would be neat to do wave-forms, randomness and audio-reactivity through the graph; this requires processing the graph itself in either python or OF. 
 - To do this in python requires programmatic OSC dispatch of attributes: right now that's setting uniforms and file loading. We could have python loop over the graph ever 100ms 'tick' and send its OSC, I suggest uniforms be sent via regular OSC, whereas changing the graph structure requires a reload of the json. (could be via osc)
 - if you do the processing in OF (you could do it in both/either and send stuff back and forth via osc) you can use OpenCV to do stuff like video-reactive audio. however you have to implement it in C++, and you put more logic in the update/draw loop which is bad. Also the python implementation of this is already much of the way there because of the plugin work.
   
   
*** Usage
Create a dot graph  as in [[Simple Recur Graph]], then use the code in [[Dot To JSON][Dot To JSON]] to topologically sort the graph and dump it as a JSON array. Notice how this generates OSC addresses; they work differently than what the shader layers use; they expect a command (see ofApp.cpp `actions`, and then two floats for uniforms as normal or one/two strings for loading the shader. If you use the normal 3 shader layers, you can use the normal OSC addresses and that should work as normal (untested). (except: I revoked the ability to toggle individual shaders on/off, because that would break the graph structure.) If you want to use the existing 3 shader layers, give a node in your graph the `slot` label, as I do in the above example. Then take your JSON and fill in [[file::bin/data/3D/scene.json]] field `orderedGraph`. 
Right now, the rest of that JSON document is ignored (including 'textureOrder'), except for `enable: false`, which actually disables the /3D/ functionality, not the graph.

* Building on the Pi
You will have to restor addons.make to its original state; you'll have to roll back changes in `main.cpp` that shouldn't be in there, you may have to fiddle the fbo initiation color settings, and you will want to avoid the shaders in this fork because they are goofed up. 
All that should be taken from the branch at this point are the source files (all in `src/`) and bin/data/3D/scene.json, which needs to be placed on the conjur-relative path "3D/scene.json" or have its path changed in the setup function.

**** other stuff

#+BEGIN_SRC python :result raw :session
from toolz import dicttoolz as dtz
from dataclasses import dataclass, field
@dataclass
class Shader:
  id: str
  u_x0: float = 0
  u_x1: float = 0
  u_x2: float = 0
  u_x3: float = 0

class GenShader(Shader): ...

class Shader1(Shader):
 u_tex0: Texture

class Shader2(Shader1):
 u_tex1: Texture

sh = Shader("hypnotic_rings", 0.5, 0.5) # some new defaults

# would expand to a [sub]graph like so:
G.add_node(sh.id) # terminus
for attr, v in dtz.dissoc(sh.__dict__, 'id').items():
   G.add_node(attr, value=v)
   G.add_edge(attr, sh.id)
#+END_SRC
#+NAME 
#+BEGIN_SRC python
def make_addresses(id):
  incoming = RG[id]
  # get nodetype via label on original dot file or extrapolation afterwards
  address = [] 
  for inEdge in incoming:
    default = RG.nodes[inEdge].get('value'):
    if not (default is None):
      # we'll tell what type for OF to parse the thing as too I guess
      addresses.append( (f"/{nodeType}/{id}/{inEdge}/", type(default)) ) # i.e. "/shader/hypnotic_frag/u_x0"
      # basically the input id is equivalent to an edge label or the target node's attribute
      slot =  RG.nodes[id].get('slot')
      if not (slot is None):
         address.append( (f"/{nodeType}/{slot}/{inEdge}", type(default) ) ) # i.e. "/shader/0/u_x0"
   return addresses 

  # nodeType = id.lower().strip( set(string.printable) - set(string.ascii_letters) )
#+END_SRC
