* Schema
** Day1
 - nodes get `rendered` each cycle  [or just commands? / bindings / extractions? ]
 - A bind of effect a to effect b is a combination of an extraction and a source
 - how do we avoid re-rendering the graph every tick?
 - put commands in a map by their offset so can do the following src block
 - look for the interpreter pattern in java/c++ b/c that's what we're doing. 
#+BEGIN_SRC cpp
unordered_map<int, Command> byTicks;
vector<Command> thisCycle; //  = byTicks [ getTime() 
int clock;  // `time` after transformations
for (auto& p : byTicks) {
 // filter by key
 // note that we have already sorted our commands and created a data structure
 // which propagates the ticks . . . the graph is small so space is cheap
 if ( time % p.first ) thisCycle.push_back(p.second);
}
#+END_SRC

Note that a clock-trigger is achieved by creating time as source :: IO Float and applying modulo after its extraction
Note that the type of NOT :: Int -> Int # and may be a special case of MUL
it may be better to define the whole thing as a pure function rather than store any state, with the state being modelled somehow by Source nodes
(i.e., last state). 
the default tick is constant
the other one is infinite: i.e. loading file happens only once
#+BEGIN_SRC cpp 
class Adder {
  int X;
  int Y;
  int visit() {
    return X + Y;
 }
}
#+END_SRC 

#+BEGIN_SRC cpp
#+END_SRC
#+BEGIN_SRC dot :file state.png
digraph StateExample {
 LastState -> Adder [bind=X]
 OSC -> Adder [bind=Y]
 Adder -> NewRotation
 Adder -> LastState [label="IO"]
}
#+END_SRC

#+RESULTS:
[[file:state.png]]
 
#+BEGIN_SRC dot :file foo.png
digraph G  {
 // SourceTime -> Value -> Extract etc.
 SourceTime -> u_time
 u_tick [type=bool, default=false]
 SourceTime -> Modulo4 ->  NOT -> u_tick 
 u_time -> Shader1
}
#+END_SRC

#+RESULTS:
[[file:foo.png]]
** Day2
#+NAME: 009BD349-7015-44AE-93D5-068599EB9F84
#+BEGIN_SRC ein-python :session http://127.0.0.1:8888/notebooks/graphs.ipynb :results raw drawer
if False:
# def resolve_edges(edges: Edges[T]) -> Tuple[T, History]
# OSC becomes a special case which overrides apply, I guess--no, it still just has a func!
 class Node[T]:

 _func: Callable[[*Node],T]
   enum: NType
   edges: Dict[ str, Node[Any] ] # could store edge types here
   edgeTypes: Dict[ str, NType ] # for dot compilation
 
   def apply(self) -> Tuple[T, History]:
     args, history = {}, []
     for e, src in edges.items(): # the edge is the label basically
       t, hist = src.apply()
       history.append(hist)
       args[e] = t
     log = self.__class, args.keys(), ags.values() 
     history.append( log )
     return _func(**args), history
 Edges =  Dict[ str, Node[T] ]
 History = Sequence [ Tuple[type, Sequence[ Node[Any] ] ] ]

# Edges = Dict[str, Node]
  # enum: NType # could just use __classname__

from dataclasses import dataclass
from typing import Callable, Any, T, Sequence
from pydantic import BaseModel # for json schemaing etc
from toolz import dicttoolz as dtz
from functools import partial 
NType = Literal[ 'ADD', 'MUL', 'SHADER', 'SCENE', 'MODEL']
History = Sequence[Tuple[type, Dict[str, str]]
@dataclass
class Node:
  _func: Callable
  edges: Dict[ str, 'Node' ] # could store edge types here
  id: str
  def edgeTypes(self) -> Dict[ str, NType ]:
    '''  useful for dot compilation'''
  # TODO: this is a class method;
  # TODO: please don't use 'return' as an attr lol 
    return tlz.dissoc( self._func.__annotations__, 'return' )

  def apply(self) -> Tuple[Any, History]:
    args, history = {}, []
    for e, src in edges.items(): # the edge is the label basically
      t, hist = src.apply()
      history.append(hist)
      args[e] = t
    log = self.__class__, dtz.valmap(args, lambda x: x.id) # args.keys(), ags.values() 
    history.append( log )
    return _func(**args), history

def _add(x: int, y: int) -> int: 
  return x + y


#class ZeroUniforms: 
# u_x0: float
# u_x1: float
# u_x2: float
# u_x3: float
#
#class OneUniforms(ZeroUniforms):
# tex0: Texture
#
#class OneUniforms(TwoUniforms):
# tex1: Texture

# class UniformBundle[T]:
#   uniforms: Sequence[T]
class UniformBundle[T]:
  uniforms: Sequence[Uniform]
# uniforms aren't really optional becuase they get set to defaults
# def shader_0_input(fileName: str, u_x0: float, u_x1: float, u_x2: float, u_x3: float) -> Texture:
# the fact that it is a class let's me cheat and store state
# class Shader(Node):
#  _func = shader_0_input
#  _fileName: str
#  def apply(self) -> Tuple[Any, History]:
#   if self._fileName != self.edges['fileName'] 
#     [LoadFile(self, self.edges['fileName'])] + super(self.__class__).apply(self)
#     # add a command 
# I keep getting wrapped up in the types and validation i.e. validating the Dot using the types
# a uniform is actually a node so don't want to do this here
# prob all this logic goes in the C++! this is just PoC here in python



class Command:
 requireChange: bool
class ChangeCommand:
  '''only run this command if inputs have changed.
  The python side of things should have been able to figure that out, though, probably....'''
  requireChange = True 
class AlwaysCommand:
 requireChange = False

# time, going into a uniform, aquires a new label, that's all
UType = Union[str, int, float, Texture]
def _id(x: UType) -> UType:
 return x

Uniform = partial(Node, _id)
class ShaderBegin(AlwaysCommand): ...

class LoadFile(ChangedCommand):
 node: Node # /  ID
 fileName: str

class SetUniform(ChangeCommand):
 uniform: Node

def shader_0_input(fileName: str, *uniforms) -> Texture: # u_x0: float, u_x1: float, u_x2: float, u_x3: float) -> Texture:
   # need an id for these commands.
  cmds = [ SetUniform( u.utype, u.label, u.value, u.id ) for u in uniforms ] # requires access to the node ids
  cmds += [ LoadFile(fileName) ] 
  cmds += [ ShaderBegin() ]
  return cmds
# have optional edges so just define a bunch of uniforms for Zero and have everybody inherit? IDK 
# i.e.g u_x0: float, u_x1: float, u_x2: float, u_x3: float) -> Texture:

class Add:
 _func = lambda x, y:  + y
 enum = "ADD"

UType = Literal[ 'float', 'int', 'bool', 'texture' ]

from functools import partial
Add = patial(Node, _add, "ADD")
Uniforms = Sequence[Uniform]
# only execute these commands if their input has changed 


  
class Shift3D(ChangeCommand):
 node: Node
 coords: Tuple[int, int, int]

class Rotate(Shift3D): ...
class Translate(Shift3D): ...
class Scale(Shift3D): ...
#+END_SRC

#+RESULTS: 009BD349-7015-44AE-93D5-068599EB9F84
:RESULTS:
[....]
:END:
** Python
#!/usr/bin/env python
# coding: utf-8

# In[70]:


#+BEGIN_SRC ein-python :session http://127.0.0.1:8888/notebooks/new.ipynb :results raw drawer
from pythonosc import udp_client
import time
localhost = "127.0.0.1"
port = 8000

client = udp_client.SimpleUDPClient(localhost, port)
# working
def msg(id, frag_name, U, on=True):
  vert_shader = 'shaders/shader.vert'
  msgs = [ ("LOAD_FILE", id, vert_shader, frag_name),
  ("TOGGLE_ACTIVE", id, on)] + \
    [("UPDATE_UNIFORM", id, i, U) for i in range(4)]

  for msg in msgs:
    time.sleep(.1)

    # print(msg)
    client.send_message("/graph", msg)
print('okay')
#+END_SRC


# In[108]:


# TODO:  fix the keys problem

#+NAME: Clear!
#+BEGIN_SRC ein-python :session http://127.0.0.1:8888/notebooks/new.ipynb :results silent drawer
def clear():
  msg("A", "", .8, False)
  msg("B", "", .1, False)
  msg("C", "", .1, False)
  msg("D", "", .1, False)
#+END_SRC
clear()


# In[107]:



#+NAME: 9D698AC8-8621-47A6-8F3F-CE3C6CAA4A7B
#+BEGIN_SRC ein-python :session http://127.0.0.1:8888/notebooks/new.ipynb :results raw drawer
for x in range(1):
  gen_shader = 'shaders/hypnotic_rings.frag'
  simple_gen = 'RECUR/0-input/squarewaves.frag'
  kscope = 'shaders/kaleidoscope-failing.frag'
  invert = 'shaders/invert.frag'
  mirrorX = 'shaders/mirrorX.frag'
  mirrorY = 'shaders/mirrorY.frag'
  blend = 'shaders/blend.frag'
  client.send_message("/shader/start", True)
  msg("A", simple_gen, .8)
#  msg("B", mirrorX, .5)
#  msg("C", mirrorY, .1)
  # msg("D", mirror, .1)
## msg("C", 'shadres/invert.frag' .5)
  print('sent')
  # time.sleep(6)
print('done.')
#+END_SRC


# In[111]:


clear()
msg("A", simple_gen, .8)
msg("B", mirrorX, .8)
msg("C", blend, .8)
#msg("C", mirrorY, .1)


# In[112]:


import typing


# In[114]:


def add(x: int, y: float) -> str:
    return 'bar'


# In[135]:



Const = Uniform

Add('a1', Mul('m1', Const('c1', 2), Const('c2', 4)), Const('c3', 3))


# In[136]:


s = set()


# In[133]:


from dataclasses import dataclass
from typing import Callable, Any, T, Sequence, Tuple, Dict, Union
from typing_extensions import  Literal
from pydantic import BaseModel # for json schemaing etc
from toolz import dicttoolz as dtz
from functools import partial 
NType = Literal[ 'ADD', 'MUL', 'SHADER', 'SCENE', 'MODEL']
History = Sequence[Tuple[type, Dict[str, str]]]
@dataclass
class Node:
  _func: Callable
  edges: Dict[ str, 'Node' ] # could store edge types here
  id: str
  def edgeTypes(self) -> Dict[ str, NType ]:
    '''  useful for dot compilation'''
  # TODO: this is a class method;
  # TODO: please don't use 'return' as an attr lol 
    return tlz.dissoc( self._func.__annotations__, 'return' )

  def apply(self) -> Tuple[Any, History]:
    args, history = {}, []
    for e, src in edges.items(): # the edge is the label basically
      t, hist = src.apply()
      history.append(hist)
      args[e] = t
    log = self.__class__, dtz.valmap(args, lambda x: x.id) # args.keys(), ags.values() 
    history.append( log )
    return _func(**args), history

def _add(x: int, y: int) -> int: 
  return x + y

def _mul(x: int, y: int) -> int:
    return x * y

def _id(x: UType) -> UType:
 return x

Add = partial(Node, _add)
Mul = partial(Node, _mul)
# just treat a uniforms like any other edge I guess
                   
class Texture: ...
UType = Union[str, int, float, Texture]
Uniform = partial(Node, _id)
Const = Uniform
class Command:
 requireChange: bool

class ChangeCommand(Command):
  '''only run this command if inputs have changed.
  The python side of things should have been able to figure that out, though, probably....'''
  requireChange = True 

class AlwaysCommand(Command):
 requireChange = False

class ShaderBegin(AlwaysCommand): ...

class LoadFile(ChangeCommand):
 node: Node # /  ID
 fileName: str

class SetUniform(ChangeCommand):
 uniform: Node

def shader_0_input(fileName: str, *uniforms) -> Texture: # u_x0: float, u_x1: float, u_x2: float, u_x3: float) -> Texture:
   # need an id for these commands.
  cmds = [ SetUniform( u.utype, u.label, u.value, u.id ) for u in uniforms ] # requires access to the node ids
  cmds += [ LoadFile(fileName) ] 
  cmds += [ ShaderBegin() ]
  return cmds


# In[123]:


xtb: Callable[[int,int],int] = lambda a, b: a*b


# In[ ]:





# In[124]:


xtb.__annotations__

# add._func


** e.g. Haskell
:PROPERTIES:
:header-args:haskell: :prologue ":{\n" :epilogue ":}\n"
:END:
#+begin_src haskell :results output
:set prompt-cont ""
#+end_src

#+RESULTS:

#+begin_src haskell :results raw
pyth5 n =
  [ (x, y, z)
  | x <- [1 .. n]
  , y <- [x .. n]
  , z <- [y .. n]
  , x ^ 2 + y ^ 2 == z ^ 2
  ]
#+end_src


#+begin_src haskell :results raw
pyth5 5  
#+end_src




#+BEGIN_SRC haskell 
data Foo = Bar | Baz | Bill deriving (Show,Eq)
:t Bar
:t Bill
print Bar
let f x = let y = 3 in
  y*x
f 2
#+END_SRC

#+RESULTS:
: <interactive>:146:1: error:
:     Variable not in scope: f :: Integer -> t

#+BEGIN_SRC haskell
data Label = Output | UF_f1 | UF_f2 | UF_f3  deriving (Show,Eq)
data Node = Node deriving Show
data Source = Adder Int Int | Extract Label Node | Mul Int Int deriving (Show)
print (Adder 3 3)
#+END_SRC 

Representing as subgrpahs because node attributes are actually 'Source Nodes' within a cluster
 Note: a const is different b/c it doesn't have to be recursively rendered
 'output' is just another thing to be extracted; it is the result of a side-effect of the container/subgraph (larger effects node)
 however, you might consider extracing output as monadic; it is different from a node passing on its values;
 though, consider this: any `Source` may have a monadic computation somewhere in its dependency trace. 
 Addition is an example of one such 'side-effect'


#+BEGIN_SRC dot :file subgraphs.png
digraph G {

    graph [fontsize=10 fontname="Verdana" compound=true];
    node [shape=record fontsize=10 fontname="Verdana"];

    subgraph cluster_0 {
        node [style=filled];
        "0_tex0" [label=texture] "0_out" [label=output];
        label = "Pika Model";
        color=blue;
    }

    subgraph cluster_1 {
        node [style=filled];
        "1_tex0" [label=texture] "1_out" [label=output];
        label = "1-input Shader";
        color=blue;
    }

    subgraph cluster_2 {
        node [style=filled];
        // "texture0" "Attr6";
        "2_tex0" [label=texture] "2_out" [label=output];
        label = "1-input Shader";
        color=blue;
    }

    // Edges between nodes render fine
    // "output" -> "Attr2";
    // "Attr2" -> "Attr3";
    "0_out" -> "1_tex0";
    "1_out" -> "2_tex0";

}
#+END_SRC

#+RESULTS:
[[file:subgraphs.png]]

    // Edges that directly connect one shader to another
//    "output" -> "texture0" [ltail=cluster_0 lhead=cluster_1];
//    "output" -> "texture0" [ltail=cluster_1 lhead=cluster_2];
#+BEGIN_SRC haskell
data Source = Adder Int Int 
 | Extract Label Node
 | Mul Int Int
 | Not Int
 | Const Int
 | Time Int
 | OSC Int
-- a Source is a node with a single value
type Tick = Int
data Edge = Edge Label Node Node
-- below describes expansions of the graph sort of 
data Command = Bind Tick Source Edge
  | Get Source
  | Put Int 
-- Const is the bottom; Time is secretly the other bottom
-- 
-- type Edge = Map (Label Source)
data Node = Node [(Label, Source)] -- i.e. edges. there are no attributes; attributes/defaults are edges with labels. 
-- defaults are Const-source edges.
type Default a = Bind (Const a) -- partial application?
-- or is it Adder -> Const
-- Const -> 
get :: (Monad m) => Source -> m Int
get (Adder x y)   = pure $ x + y 
get (Const x)     = pure x
get (Extract l (Node edges)   = get (find (== l))
visit (Adder x y) = Source (x + y)
#+END_SRC

#+RESULTS:
[[file:subgraphs.png]]





* Here
 - shaderActive needs to be changed. 
    - we don't need to check if it's active b/c it's either in the nodemap or it isn't
 - osc addresses need to be fixed (use an action map or a visitor, and generate addresses?
    or assume that the addresses are of the form
    /{command}/{arg1ID}/{arg2ID}  w/ optional float values
 - fix apply input chain (might require ofxAddons changes) [[file:~/of_v0.11.0_osx_release/apps/recur/c_o_n_j_u_r/src/ofApp.cpp::ofFbo%20ofApp::applyEffectShaderChain(vector<ofTexture>%20effectInput){][shaderChain]]
     ofFbo ofApp::applyEffectShaderChain(vector<ofTexture> effectInput){
 - then test with mac OSC :)
#+BEGIN_SRC cpp :result raw :includes "<stdio.h>"
int z = 0;
int i = 0;
switch (z) {
  case 4:
  i++;
  break;
  case 0:
  i += 99;
  break;
 }
printf("%d", i);
#+END_SRC

#+RESULTS:
: 99

#+BEGIN_SRC cpp
// you could generate OSC addresses but this is easier for now
string cmd = m.getArgAsString(0);
Id nodeId = m.getArgAsString(1);
ofxNode node = nodes[nodeId];
actionMap actions = { { { "LOAD_FILE", LOAD_FILE}, 
                         {"UPDATE_UNIFORM", UPATE_UNIFORM} } };
if (cmd == "LOAD_FILE") {
  dispatchUn(LOAD_FILE, node, m.getArgAsString(2));
}
else if (cmd == "UPDATE_UNIFORM") {
  dispatchUn(UPDATE_UNIFORM, node, m.getArgAsString(2), m.getArgAsFloat(3))
}

int dispatchUn(Action act, ofxNode node, string arg1, float arg2) {
int dispatchUn(Action act, ofxNode node, string arg1, string arg2) {
 
 switch act {
  case (LOAD_FILE):
    ofxNode.loadShaderFiles(arg1, arg2);
    return 0;
  default:
    return -1;
}

}
    
#+END_SRC

#+RESULTS:

* Problems
something is happening where texCoordVarying is always zero for simple.frag
* Tests

#+NAME: Setup!
#+BEGIN_SRC ein-python :session http://127.0.0.1:8888/notebooks/new.ipynb :results raw drawer
from pythonosc import udp_client
import time
localhost = "127.0.0.1"
port = 8000

client = udp_client.SimpleUDPClient(localhost, port)
# working
def msg(id, frag_name, U, on=True):
  vert_shader = 'shaders/shader.vert'
  msgs = [ ("LOAD_FILE", id, vert_shader, frag_name),
  ("TOGGLE_ACTIVE", id, on)] + \
    [("UPDATE_UNIFORM", id, i, U) for i in range(4)]

  for msg in msgs:
    time.sleep(.1)

    # print(msg)
    client.send_message("/graph", msg)
print('okay')
#+END_SRC

#+RESULTS: Setup!
:RESULTS:
[....]
:END:





#+NAME: Clear!
#+BEGIN_SRC ein-python :session http://127.0.0.1:8888/notebooks/new.ipynb :results silent drawer
msg("A1-0", gen_shader, .8, False)
msg("B2-0", invert, .1, False)
msg("C3-1", kscope, .1, False)
msg("D4-2", kscope, .1, False)
#+END_SRC

#+NAME: 9D698AC8-8621-47A6-8F3F-CE3C6CAA4A7B
#+BEGIN_SRC ein-python :session http://127.0.0.1:8888/notebooks/new.ipynb :results raw drawer
for x in range(1):
  gen_shader = 'shaders/hypnotic_rings.frag'
  simple_gen = 'shaders/simple.frag'
  kscope = 'shaders/kaleidoscope-failing.frag'
  invert = 'shaders/invert.frag'
  mirrorX = 'shaders/mirrorX.frag'
  mirrorY = 'shaders/mirrorY.frag'
  client.send_message("/shader/start", True)
  msg("A1-0", simple_gen, .8)
#  msg("B2-0", mirrorY, .5)
#  msg("C3-1", mirrorX, .1)
  # msg("D4-2", mirror, .1)
## msg("C3-1", 'shadres/invert.frag' .5)
  print('sent')
  # time.sleep(6)
print('done.')
#+END_SRC

#+RESULTS: 9D698AC8-8621-47A6-8F3F-CE3C6CAA4A7B
:RESULTS:
[....]
:END:











